---
title: "ClusterZI - Vignette"
output:
  pdf_document: default
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE)
library(tidyverse)
library(ggplot2)
library(ClusterZI)
library(gridExtra)
library(kableExtra)
```

```{r, include=FALSE}
# library(Rcpp)
# library(devtools)
# uninstall(); compileAttributes(); build(); install()
# compileAttributes(); build(); install()
```

```{r, eval = FALSE, include=FALSE}
install.packages("~/Desktop/Github Repo/ClusterZI_1.0.tar.gz", repos = NULL, type="source")
```

# Introduction

This vignette demonstrates how to implement semi-parametric clustering methods on microbiome data, which is assumed to follow the Zero-Inflated Dirichlet-Multinomial distribution as explained in the main manuscript, ["Main Manuscript"]. It begins with brief instructions on how to install the packages for implementing the proposed model. Next, the document provides guidance on simulating the data used in the main manuscript. Finally, it covers the implementation of the model on both simulated and application data.

# Installation

To install the package, we run the command below: 

```{r install, eval=FALSE}
devtools::install_github("skorsu/ClusterZI")
```

# Simulation Data

In this section, we demonstrate how to obtain the simulated data used in the main manuscript. After installing and loading the `ClusterZI` package into the R environment, we use the `sim_clusDat()` function to generate two-cluster Zero-Inflated Dirichlet-Multinomial distributed data.

```{r}
### Simulate the data
simDat <- sim_clusDat(n = 100, Jnoise = 150, Jsignal = 50, pZero = 0.35, 
                      ZSumNoise = 12500, ZSumSignal = 2500, seed = 1)
```

To use the `sim_clusDat()` function, we need to specify several parameters: the number of observations $(n)$, the number of noise taxa (taxa that do not contain information about the clustering) $(J_{\text{noise}})$, the number of signal taxa (taxa that differentiate between clusters) $(J_{\text{signal}})$, the proportion of zeros expected in the simulated dataset (pZero), the sequencing depth for both noise and signal taxa (ZSumNoise and ZSumSignal, respectively), and the random seed (seed). Note that the `sim_clusDat()` function splits the observations into two clusters evenly. The result from the `sim_clusDat()` function is a list consisting of two elements: the simulated OTU table (dat) and the cluster allocation for each observation (c). For example, in this case, we have simulated 100 observations with 200 taxa, 50 of which are considered signal taxa. In this simulated dataset, we expect that around 35% of the counts are zero. The assumed sequencing depth for each observation is 15,000, with 12,500 for the noise taxa and 2,500 for the signal taxa. We save the simulated data in the object named `simDat`. To access the simulated OTU table, we use `simDat$dat`, while `simDat$c` gives us the cluster allocation.

Note that there are six other default arguments, which are listed below:

  - shuffle: Determines whether the order of observations should be shuffled. The default is TRUE. If set to FALSE, observations from the same cluster will be grouped together.
  - caseSignal: This is the complexity index, ranging from 1 to 5, where 1 is the most complex and 5 is the least complex. The default is 3.
  - aPhi, bPhi, aLambda, bLambda: These parameters control the characteristics of each cluster.

The limitation of the `sim_clusDat()` function is that it is suitable for simulating data from only two clusters. However, we can manually extend this function to generate more than two clusters. For example, if we want to generate 200 observations with four different clusters, where the cluster sizes are 60, 60, 40, and 40, respectively, we can use the code below.

```{r}
### Extend the code for simulating 4 clusters.
#### Generate the first 120 observations, 60 from each cluster,
simDat_1 <- sim_clusDat(n = 120, Jnoise = 150, Jsignal = 50, pZero = 0.35, 
                        ZSumNoise = 12500, ZSumSignal = 2500, seed = 1, shuffle = FALSE) 
#### Generate the other 80 observations, 40 from each cluster,
simDat_2 <- sim_clusDat(n = 80, Jnoise = 150, Jsignal = 50, pZero = 0.35, 
                        ZSumNoise = 12500, ZSumSignal = 2500, seed = 1, shuffle = FALSE)

#### Rearrange the order of the taxa to differentiate among these 4 clusters
simDat_4clus <- rbind(simDat_1$dat,
                      cbind(simDat_2$dat[1:40, 151:200], simDat_2$dat[1:40, -(151:200)]),
                      cbind(simDat_2$dat[41:80, 1:50], simDat_2$dat[1:40, 151:200], 
                            simDat_2$dat[1:40, 51:150]))

#### Optional: Shuffle the order of the observations
set.seed(1)
index <- sample(1:200)
simDat_4clus <- simDat_4clus[index, ]
simDat_4clus_c <- c(simDat_1$c, simDat_2$c + 2)[index]
```

# Implementing the Model

In this section, we walk through how to implement the discrete sparse finite mixture model on the simulated data, along with the possible posterior inference on the parameters of interest. The primary function used for implementing the discrete sparse finite zero-inflated Dirichlet-Multinomial model is `ZIDM_dSDMMM()`.

```{r, eval=FALSE}
resultMod <- ZIDM_dSDMMM(dat = simDat$dat, iter = 1500, Kmax = 10, nxi_split = 10, 
                         theta = 1, s2 = 0.1, s2MH = 1e-3, MHadapt = 500, 
                         thin = 1, seed = 1)
```

```{r, include=FALSE}
resultMod <- readRDS(file = "~/Desktop/Github Repo/ClusterZI/data/resultMod_vig.rds")
```

This function requires us to specify the data to which we will apply the model (dat), the number of MCMC iterations (iter), the number of components (Kmax), the sparsity concentration parameter (theta), the variance of the cluster concentration parameter (s2), the variance for the adaptive Metropolis-Hasting when updating the cluster concentration parameter (s2MH), the number of MCMC iterations before using the adaptive proposal (MHadapt), thinning (thin), and the random seed (seed). Note that the `ZIDM_dSDMMM()` function initializes all observations in the same cluster. In this example, we specify that we will apply the model to the simulated data we previously generated (`simDat$dat`). We let the model run for 15,000 iterations, where the first 500 iterations use a non-adaptive proposal for the adaptive Metropolis-Hasting (AMH). We set the variance of the cluster concentration parameter to 0.1, and the variance of the adaptive Metropolis-Hasting to $1 \times 10^{-3}$. We limit the clusters to no more than 10 clusters. Besides, if we propose to split the cluster space, the proposed cluster concentration parameters are obtained by using the cluster concentration parameters corresponding to the original cluster, while 10 of the random taxa have different cluster concentration parameters.

The result from the `ZIDM_dSDMMM()` function is a list object. To obtain the final cluster assignment, we use the `finalCLUS()` function. We need to specify the number of iterations to consider as a burn-in period. We utilize the `salso()` function from the `salso` package with the VI loss function [@salso] to determine the final cluster assignment.

```{r}
### Obtain a vector of the final cluster assignment.
clusResult <- finalCLUS(resultMod, burn_in = 500, seed = 1)
```

We can obtain the Adjusted Rand Index (ARI) to measure the performance of the resulting cluster compared to the actual cluster assignment (if applicable) by using the `ariCLUS()` function.

```{r, eval=FALSE}
### Calculate the ARI
ariCLUS(clusResult, simDat$c)
#> 1
```

## Posterior Inference

We then proceed with the posterior inference on the parameters of interested, which is the number of active cluster via MCMC iterations. We use `uniqueCLUS()` to obtain the number of active cluster in each MCMC chain. We demonstrate the number of active cluster by using the line plot, as shown in Figure 2.

```{r}
### Obtain a vector of the number of active cluster for each MCMC iteration.
clusMCMC <- uniqueCLUS(resultMod) 
```

# Application Data

In this section, we discuss how to apply the proposed model to the application data, mentioned in the main Manuscript, which are the HIV dataset, collected by @noguera2016gut and can be accessed from the `selbal` package [@rivera2018balances], and EDD dataset, provided by @singh2015intestinal and make it publicly available by @duvallet2017meta. In this vignette, we use the HIV dataset for demonstrating how to apply the proposed model on the real-world dataset. We first load the data into the R environment. The first column is the observation ID, where the second and third column are the metadata corresponding to each observation. Note that for the EDD dataset, only the second column is the metadata.

```{r}
### Import the dataset
data("selbalHIV")
otuHIV <- selbalHIV[, -(1:3)] ### Obtain the OTU table
metaHIV <- selbalHIV[, 1:3] ### Obtain the metadata
```

We then apply the proposed model to the HIV dataset, running it for 25,000 MCMC iterations without thinning. We decide to use the adaptive proposal for the AMH after the first 2,500 iterations. The variance of the cluster concentration parameter is set to 1, and the variance of the adaptive Metropolis-Hastings is set to $1 \times 10^{-3}$. We limit the model to a maximum of 20 clusters. Additionally, if a split in the cluster space is proposed, the new cluster concentration parameters are derived from those of the original cluster, with 5 randomly selected taxa having different concentration parameters.

```{r, eval = FALSE}
### Apply the model on the HIV dataset.
HIVMod <- ZIDM_dSDMMM(dat = otuHIV, iter = 25000, Kmax = 20, nxi_split = 5, 
                      theta = 1, s2 = 1, s2MH = 1e-3, MHadapt = 2500, 
                      thin = 1, seed = 1)
```

```{r, include=FALSE}
HIVMod <- readRDS(file = "~/Desktop/Github Repo/ClusterZI/data/resultApp_vig.rds")
HIVMod <- HIVMod$mod
```

We obtain the final cluster assignment by using `finalCLUS()` function. We then see the ability of the model to recover the cluster pattern in the data by considering the resulting cluster with the metadata, as shown in Table 2. The result reveals that similar finding as discussed in @noguera2016gut.

```{r}
### Obtain the final cluster assignment for the HIV dataset.
HIVclus <- finalCLUS(HIVMod, burn_in = 5000, seed = 1)
```

We also consider the number of active clusters across MCMC iterations by applying the `uniqueCLUS()` function. The result, illustrated in Figure 3, shows that the number of active clusters stabilizes after the first few iterations.

```{r}
### Calculate the number of the active cluster for each MCMC iteration.
HIVMCMC <- uniqueCLUS(HIVMod) 
```

\newpage

```{r, echo = FALSE, fig.cap = "Heatmaps of the simulated data. Left: Data generated by the `sim_clusDat()` function, saved as `simDat`. Right: Data generated by an extended version of the `sim_clusDat()` function to create 4 clusters, saved as `simDat_4clus`."}
### 2 Clusters
simDat_Long <- data.frame(simDat$dat, i = 1:100) %>%
  pivot_longer(!i)
simDat_Long$i <- factor(simDat_Long$i, levels = sort(simDat$c, index.return = TRUE)$ix)
simDat_Long$name <- factor(simDat_Long$name, levels = paste0("X", 1:200))
p1 <- ggplot(simDat_Long, aes(x = name, y = i, fill = value)) +
  geom_tile() +
  scale_fill_gradient(low = "white", high = "red") +
  theme_bw() +
  theme(legend.position = "none", axis.text = element_blank()) +
  labs(x = "Observation", y = "Taxa")

### 4 Clusters
simDat_Long_4c <- data.frame(simDat_4clus, i = 1:200) %>%
  pivot_longer(!i)
simDat_Long_4c$i <- factor(simDat_Long_4c$i, levels = sort(simDat_4clus_c, index.return = TRUE)$ix)
simDat_Long_4c$name <- factor(simDat_Long_4c$name, levels = paste0("X", 1:200))
p2 <- ggplot(simDat_Long_4c, aes(x = name, y = i, fill = value)) +
  geom_tile() +
  scale_fill_gradient(low = "white", high = "red") +
  theme_bw() +
  theme(legend.position = "none", axis.text = element_blank()) +
  labs(x = "Observation", y = "Taxa")

grid.arrange(p1, p2, nrow = 1)
```

```{r, echo=FALSE, fig.cap = "The line plot shows the number of active clusters for each MCMC iteration when the model is applied to the simulated data `(simDat)`."}

### Create the plot for the active cluster via MCMC iteration
data.frame(clusMCMC, iter = 1:1500) %>%
  ggplot(aes(x = iter, y = clusMCMC)) +
  geom_line() +
  theme_bw() +
  scale_y_continuous(breaks = seq(1, 10, 1)) +
  labs(x = "MCMC Iteration", y = "# Active Cluster")
```

```{r, echo=FALSE, fig.cap = "The line plot shows the number of active clusters for each MCMC iteration when the model is applied to the application data `(selbalHIV)`."}

### Create the plot for the active cluster via MCMC iteration
data.frame(HIVMCMC, iter = 1:25000) %>%
  ggplot(aes(x = iter, y = HIVMCMC)) +
  geom_line() +
  theme_bw() +
  scale_y_continuous(breaks = seq(1, 10, 1), limits = c(1, 10)) +
  labs(x = "MCMC Iteration", y = "# Active Cluster")
```

```{r, echo = FALSE}
examMeta <- head(metaHIV)
rownames(examMeta) <- NULL
kbl(examMeta, col.names = c("ID", "Sexual Preference", "HIV Status"), 
    caption = "Example of the metadata for the HIV dataset. The first column contains the observation ID, while the other two columns represent the metadata for each individual: sexual preference and HIV status, respectively.") %>%
  kable_classic(full_width = FALSE, position = "center")
```

```{r, echo = FALSE}
data.frame(HIVclus, sex = metaHIV[, 2], status = metaHIV[, 3]) %>%
  group_by(HIVclus, sex, status) %>%
  summarise(f = n()) %>%
  pivot_wider(names_from = c(sex, status), values_from = f, values_fill = 0) %>%
  kbl(col.names = c("HIVclus", "Healthy: non-MSM", "HIV: non-MSM",
                    "Healthy: MSM", "HIV: MSM"), 
    caption = "Distribution of patients and sexual preferences within the resulting clusters.") %>%
  kable_classic(full_width = FALSE, position = "center")
```

\newpage

# Reference



